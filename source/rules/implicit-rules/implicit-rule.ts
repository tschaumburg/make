import * as path from "path";
import { BoundImplicitRule } from "./bound-implicit-rule";
import { Recipe, IRule } from "../rule";
import { ITarget } from "../target";
import { ITargetManager } from "../targets";

export class ImplicitRule
{
    constructor(
        public readonly targetPatterns: string[],
        public readonly prerequisitePatterns: string[],
        public readonly recipe: string[]
    ){}

    apply(
        dirName: string,
        stem: string,
        targetManager: ITargetManager
    ): IRule
    {
        let targets = 
            this.targetPatterns
            .map(p => p.replace("%", stem))
            .map(name => targetManager.addTarget(name, path.resolve(dirName, name), false));

        let prerequisites = 
            this.prerequisitePatterns
            .map(p => p.replace("%", stem))
            .map(name => targetManager.addTarget(name, path.resolve(dirName, name), false));

        return new BoundImplicitRule(targets, prerequisites, new Recipe(this.recipe));
    }

    stems(targetName: string): string[]
    {       
        let res: string[]= [];
        for (const pattern of this.targetPatterns)
        {
            let s = this.stem(pattern, targetName);
            if (!!s)
            {
                res.push(s);
            }
        }

        return res;
    }

    private stem(pattern: string, targetName: string): string
    {       
         let stemLength = targetName.length - pattern.length + 1;
        if (stemLength < 1)
        {
            return null;
        }
    
        let parts = pattern.split('%');
        if (parts.length != 2)
        {
            return null;
        }
    
        if (!targetName.startsWith(parts[0]))
        {
            return null;
        }
    
        if (!targetName.endsWith(parts[1]))
        {
            return null;
        }
        
        return targetName.substr(parts[0].length, stemLength);   
    }
}

// import * as path from 'path';
// import { IRule, IImplicitRule, IMakefile, ITarget, IRecipe } from '../imakefile';


// class ImplicitRule implements IImplicitRule
// {
//     constructor(
//         private readonly parent: IMakefile,
//         public readonly targetPatterns: string[],
//         public readonly prerequisitePatterns: string[],
//         public readonly recipe: IRecipe
//     ){}

//     public match(dirName: string, targetName: string): string[]
//     {
//         let self = this;
//         var res =
//             this.targetPatterns
//                 .map(pattern => self._stem(pattern, targetName))
//                 .filter(stem => self._canApply(stem));
//                 // .sort((a, b) => a.length - b.length);
//         return res;
//     }

//     // public stem(targetName: string): string[]
//     // {
//     //     let self = this;
//     //     var res =
//     //         this.targetPatterns
//     //             .map(pattern => self._stem(pattern, targetName))
//     //             .filter(s => !!s)
//     //             .sort((a, b) => a.length - b.length);
//     //     return res;
//     // }

//     private apply(dirName: string, stem: string): IRule
//     {
//         if (!stem)
//             return null;
        
//         // lets look at each target pattern, expand it into a
//         // target full-name, and see if it's free for us to generate.
//         let targetNames = this.targetPatterns.map(p => p.replace("%", stem));
//         for (let targetName of targetNames)
//         {
//             // - if the target is not generated by any rule yet,
//             //   then that target is OK for us to generated
//             if (!this.parent.findTarget(path.resolve(dirName, targetName)))
//                 continue;

//             // ...other situations where double-definitions of targets
//             // are OK?

//             // if not, this rule cannot be used:
//             return null;
//         }

//         let prereqNames = this.prerequisitePatterns.map(p => p.replace("%", stem));
//         for (let prereqName of prereqNames)
//         {
//             // - if the target is generated already we're fine.
//             if (!this.parent.findTarget(path.resolve(dirName, prereqName)))
//                 continue;
                
//             if (!this.parent.findImplicit(path.resolve(dirName, prereqName)))
//                 continue;
//         }
//     }

//     private _stem(pattern: string, targetName: string): string
//     {        let stemLength = targetName.length - pattern.length + 1;
//         if (stemLength < 1)
//         {
//             return null;
//         }
    
//         let parts = pattern.split('%');
//         if (parts.length != 2)
//         {
//             return null;
//         }
    
//         if (!targetName.startsWith(parts[0]))
//         {
//             return null;
//         }
    
//         if (!targetName.endsWith(parts[1]))
//         {
//             return null;
//         }
        
//         return targetName.substr(parts[0].length, stemLength);    }
// }

